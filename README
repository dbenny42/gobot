David Benedetto & Stephen Pratt
Parallel Programming

Gobot - The Go-Playing Parallel Bot



INVOCATION:

make play  # will build and start a 7x7 verison of the human VS. AI game.

# to play again, with a different board size:
./Go <height> <width> <1 or 2 human players>



NOTES ON USAGE

To make a move against the AI, type the row, then column of the piece that
you wish to play, such as "a2", "b4", or "c5", as they are labeled on the
board printout.

If you attempt a compilation without using the Makefile, please use the
C++ compiler, as we had some currently-unexplained compiler errors occur
at the level of Java code, but not at X10 code.



MILESTONE 2 REPORT

WHERE WE STAND
At this point in time, we have implemented a serial version of the core AI
involved in playing Go (according to the Chinese Rules), with the
exception that we use a restricted version of scoring*, to simplify current
implementation.

Our AI makes its decisions based on a Monte Carlo Tree Search.  A general
version of our approach is described in "A Survey of Monte Carlo Tree
Search Methods", which can be found at
http://www.cameronius.com/cv/mcts-survey-master.pdf.

We have built no automated tests or benchmarks, instead working toward
the goal suggested by Professor Kim in our feedback from Milestone 1,
namely, a working human VS. computer version of the game.  For small board
sizes (such as 5x5 or 7x7), our AI remains unbeaten by both Stephen and
David, while for larger board sizes, such as 19x19 (the actual board
size), the search space is still too large for our serial implementation
to handle well, leading to (extremely) poor play.

Just for fun, we have a human VS. human option, which we used to test
non-parallel aspects of Go, such as superko, the rule that a board state
can occur no more than once per game.


REMAINING GOALS
-Parallel implementation of AI decision making.
-->Monte Carlo Tree Search allows for enormous parallelism.  So long as
   individual increments during back-propagation (described in "A Survey
   of...") occur atomically, we believe we can fully parallelize each
   branch of randomly generated game states, giving us a huge advantage
   over serial implementation.

-Improved end-of-game function.
-->The current AI is unable to actually finish a game.  It plays right to
   the point of beating the opponent, but cannot currently finish the
   game, because of the tricky nature of how games of Go end.  For the
   game to finish, both players must "pass".  However, we've had some
   difficulty convincing the AI of the proper situations to pass.  We are
   not especially worried about this, as the core AI is working well in
   serial, and we are optimistic about improvements.

-Addition of choice-of-color for human players.  
-->Player currently only plays as white; this should be a relatively
   simple addition to make, and is non-parallel in nature.

-Full scoring 
-->As stated above, to limit the amount of computation our AI currently
   performs, we restricted scoring to a count of the pieces on the board.
   By the next milestone, we expect to have full scoring implemented.

-Better Resource Bounds
-->Monte Carlo Tree Search involves "playing" random game paths until a
   certain resource bound is reached.  To get our AI working, we set up a
   fixed resource bound of ten seconds, which seems to yield good
   performance for 7x7 boards, but horrible performance for 19x19 boards.
   A better version of resource bounding would only compute a certain
   number of game nodes, with that certain number calculated as a function
   of the board size and / or the number of open spaces left on the board,
   yielding a sharper AI for varied board sizes, and better response times
   as the game progresses, as with human players.

-Interface with batch environment and GnuGo, for automated testing.

*Full scoring involves tracking territory on the board that is surrounded
by same-colored pieces, which involves large amounts of searching that we
wished to avoid while trying to get a viable AI, the crux of the project.